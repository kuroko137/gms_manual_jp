<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>

  <script type="text/javascript" language="JavaScript">
    //<![CDATA[
    function reDo() {
      if (innerWidth != origWidth || innerHeight != origHeight)
        location.reload();
    }
    if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
      origWidth = innerWidth;
      origHeight = innerHeight;
      onresize = reDo;
    }
    onerror = null;
  //]]>
  </script>
  <style type="text/css">/*<![CDATA[*/

    < !-- div.WebHelpPopupMenu {
      position: absolute;
      left: 0px;
      top: 0px;
      z-index: 4;
      visibility: hidden;
    }

    p.WebHelpNavBar {
      text-align: right;
    }

    -->
  
/*]]>*/</style>

  <script type="text/javascript">//<![CDATA[

    gRootRelPath = "../..";
    gCommonRootRelPath = "../..";
    gTopicId = "10.1.1_7";
  
//]]></script>

  <script type="text/javascript" src="../../template/scripts/rh.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/common.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/topic.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/topicwidgets.min.js"></script>
<script type="text/javascript" src="../../whxdata/projectsettings.js"></script>
  <link rel="stylesheet" type="text/css" href="../../template/styles/topic.min.css" />
  <link rel="stylesheet" type="text/css" href="../../template/Charcoal_Grey/topicheader.css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <title>アクセサ</title>
  <meta name="topic-status" content="Draft" />

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>アクセサ</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining the different Accessors" />
  <meta name="rh-index-keywords" content="アクセサ" />
  <meta name="search-keywords" content="Accessors,@,[| ],[@ ],[# ],[? ],grid accessor,list accessor,map accessor,array accessor" />
</head>

<body>
  <div class="topic-header rh-topicheader-hide" id="rh-topic-header" onclick="rh._.goToFullLayout()">
    <div class="logo">
    </div>
    <div class="nav">
      <div class="title" title="アクセサ">
        <span>アクセサ</span>
      </div>
      <div class="gotohome" title="ページをすべて表示するにはここをクリック">
        <span>ページをすべて表示するにはここをクリック</span>
      </div>
    </div>
  </div>
  <div class="topic-header-shadow"></div>



  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>アクセサ</h1>
  <p>GameMaker Language (GML) では、<b>アクセサ</b>と呼ばれる論理式を使用して、特定の<a href="../GML_Reference/Data_Structures/Data_Structures.htm">データ構造</a>や<a href="Arrays.htm">配列</a>にアクセスすることができます。これは、普通の配列を扱う場合と似た仕組みですが、GameMaker Studio 2 では、第一引数の前に<em>識別子</em>を使用して、(事前に作成された) データ構造や配列リテラルを扱っていることを伝えています。</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#"><span data-open-text="true">DS Lists [| ]</span><span data-close-text="true">DS Lists [| ]</span></a></p>
  <div class="droptext" data-targetname="drop-down10">
    <p class="dropspot"><a href="../GML_Reference/Data_Structures/DS_Lists/DS_Lists.htm">DS リスト</a>の構文:</p>
    <p class="code">list_index[| index]</p>
    <p class="dropspot"><tt>ds_list_create</tt> を使ってリストを作成した場合、(変数に格納した) リストのインデックスはリストを参照するために使用し、また "インデックス" の値をリスト内において設定または追加する位置にできます。例えば、以下のコードはリストを作成してから 10 個のエントリを追加し、各エントリに 0 から 9 までの乱数を設定します。</p>
    <p class="code">ds = ds_list_create();<br /> var index = 0;<br /> repeat(10) <br />     { <br />     ds[| index++] = irandom(9);<br />     }
    </p>
    <p class="dropspot">既に値を持っているインデックスへ参照を追加するために式を使用している場合、リストに追加されたインデックスではなく、前の値が置き換えられてしまうことに注意してください。さらにエントリを追加するには ds_list のサイズを知り、最後に追加する必要があります。また、参照しているリストのサイズよりも<i>大きい</i>リストインデックスを設定することができ、その値を設定すると同時にリストが展開され、与えられたインデックスまでのリスト内のすべての位置が 0 として初期化されます。</p>
    <p class="dropspot">リスト構造を作成してデータを入力した時点で、リストから値を取得するには次のようにします。</p>
    <p class="code">value = ds[| 5];</p>
    <p class="dropspot">上の例では、5 番目の位置 (リストは 0 から始まるので 6 番目のインデックス)から値を取得して変数に格納します。リストのサイズ外の位置を指定した場合は <tt>undefined</tt> が返されます。これは関数 <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><tt>is_undefined()</tt></a> で確認できます。</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#"><span data-open-text="true">DS Maps [? ]</span><span data-close-text="true">DS Maps [? ]</span></a></p>
  <div class="droptext" data-targetname="drop-down13">
    <p class="dropspot"><a href="../GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">DS マップ</a>の構文:</p>
    <p class="code">map_index[? key]</p>
    <p class="dropspot"><tt>ds_map_create()</tt>でマップを作成した後、変数に格納したマップインデックスを使用して参照し、"key" の値を設定または取得するマップキーとします。たとえば、次のコードは、マップを作成し、この構文を使用してそこにいくつかのエントリを追加しています。</p>
    <p class="code">ds = ds_map_create();<br /> ds[? "Name"] = "Hamish";<br /> ds[? "Company"] = "MacSeweeny Games";<br /> ds[? "Game"] = "Catch The Haggis";</p>
    <p class="dropspot">マップに追加しようとしているキーと同じキーがすでに含まれている場合は、新しい値との重複キーは作成されず、前の値が置換されることに注意してください。</p>
    <p class="dropspot">マップ構造体を作成してデータを入力したら、特定のマップ キーから値を取得するたには次のようにします。</p>
    <p class="code">value = ds[? "Name"];</p>
    <p class="dropspot">上記はキー "Name" から値を取得して変数に格納していますが、与えられたキーが DS マップに存在しない場合、返される値は <tt>undefined</tt> になることに注意してください。これは関数 <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><tt>is_undefined()</tt></a>を使って確認することができます。</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#"><span data-open-text="true">DS Grids [# ]</span><span data-close-text="true">DS Grids [# ]</span></a></p>
  <div class="droptext" data-targetname="drop-down14">
    <p class="dropspot"><a href="../GML_Reference/Data_Structures/DS_Grids/DS_Grids.htm">DS グリッド</a>の構文:</p>
    <p class="code">grid_index[# xpos, ypos]</p>
    <p class="dropspot"><tt>ds_grid_create()</tt>関数でグリッドを作成した後、グリッド内の値を取得または設定するための位置 "xpos" と "ypos" を変数に格納したグリッドインデックスを参照するために使用します。例えば、以下のコードはグリッドを作成して 0 にクリアし、いくつかのエントリを追加しています。</p>
    <p class="code">ds = ds_grid_create();<br /> ds_grid_clear(ds, 0);<br /> var gw = ds_grid_width(ds) - 1;<br /> var gh = ds_grid_height(ds) - 1;<br /> repeat(10) <br />     { <br />     var xx = irandom(gw);<br />     var yy = irandom(gh);<br />     if (ds[# xx, yy] == 0)<br />         { <br />         ds[# xx, yy] = 1;<br />         } <br />     }
    </p>
    <p class="dropspot">グリッド構造を作成してデータを入力したら、特定のグリッドの位置から値を取得するには次のようにします。</p>
    <p class="code">value = ds[# mouse_x div 16, mouse_y div 16];</p>
    <p class="dropspot">上記は、与えられた ds_grid の値をマウスの位置に基づいて取得します（正しい位置を取得するために、部屋の "セル" の幅で割っています）。グリッドの境界線外の位置を指定した場合は <tt>undefined</tt> の値が返されますが、これは関数 <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><tt>is_undefined()</tt></a>で確認できます。</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down15" href="#"><span data-open-text="true">Arrays [@ ]</span><span data-close-text="true">Arrays [@ ]</span></a></p>
  <div class="droptext" data-targetname="drop-down15">
    <p class="dropspot">Arrays also have their own accessors which works in a similar way as those listed above for data structures. However array accessors have an interesting property and that is to permit you to modify an array from a <a href="Script_Functions.htm">script function</a> or <a href="Method_Variables.htm">method</a> without having to copy it. When you pass an array into a function, it is <strong>passed by reference</strong>, meaning that the array itself isn't being given into the script but rather it is simply being referenced to get the data. Normally if you then need to change the array, it would be <em>copied </em>to the script and then you would need to pass back (return) the copied array for the original array to be updated. This can have costly processing overheads, and so you can use the accessor instead, as that will change the original array <em>directly </em>without the need for it to be copied. You can see how this works in the examples below.</p>
    <p class="dropspot">The syntax for arrays is:</p>
    <p class="code">array[@ xpos]</p>
    <p class="dropspot">After you have created your array in an instance, you can then pass it to a script by reference and use the accessor <span class="inline">@</span> to change it directly. For example you would create the array and call the funtion like this:</p>
    <p class="code">array[99] = 0;<br /> array_populate(array);
    </p>
    <p class="dropspot">The function itself would have something like this:</p>
    <p class="code">function array_populate(_array)<br />     {<br />     var a = _array; var i = 0; repeat(25)<br />         {<br />         i = irandom(99);<br />         while (a[i] != 0)<br />             {<br />             i = irandom(99);<br />             }<br />     a[@ i] = 100;<br />         }<br />     }</p>
    <p class="dropspot">All this function is doing is selecting 25 random positions in the array and setting the value of the chosen array position to 100.</p>
    <p class="note">NOTE: You cannot use the array accessor <span class="inline">@</span> when working with the <span class="inline">argument[n]</span> array in script functions.</p>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#"><span data-open-text="true">Structs [$ ]</span><span data-close-text="true">Structs [$ ]</span></a></p>
  <div class="droptext" data-targetname="drop-down16">
    <p class="dropspot"><span>The syntax for <a href="Structs.htm">structs</a> is</span></p>
    <p class="code">struct[$ "name"]</p>
    <p class="dropspot">This accessor is essentially a wrapper for the functions <span><a href="../GML_Reference/Variable_Functions/variable_struct_get.htm"><span class="inline">variable_struct_get()</span></a> and <a href="../GML_Reference/Variable_Functions/variable_struct_set.htm"><span class="inline">variable_struct_set()</span></a>, and you would use it much like the accessor for a DS map. For example, if you have created a struct and want to retrieve a value from a variable called "my_health" then you'd do:</span>
    </p>
    <p class="code">var _hp = struct[$ "my_health"];</p>
    <p class="dropspot">As you can see, you don't supply the variable itself, but rather a <em>string</em> with the variable. Note that if the struct does not have a variable with the given name, then the accessor will return <span class="inline">undefined</span> as the value.</p>
    <p class="dropspot">To set a variable in a struct then you would do the following</p>
    <p class="code">struct[$ "my_score"] = 100;</p>
    <p class="dropspot">As with getting a value, you supply the name of the variable to set as a string, and it will be set to the value given. If the variable name used doesn't exist in the struct, then it will be created and set to the given value.</p>
    <p class="dropspot"><br /></p>
  </div>
  <p> </p>
  <p>An important feature of accessors is the fact that they can be <i>chained</i> together. This means that if you have several nested data structures and/or arrays, there is no longer the need to use a variety of functions to get access to a value that is deep within the nested structure. For example, say you have an array, and each item in the array is a DS list, like this:</p>
  <p class="code">array = array_create(3);<br /> for (var i = 0; i &lt; 3; ++i;)<br />     { <br />     array[i] = ds_list_create();<br />     switch(i) <br />         { <br />         case 0:<br />             with (obj_Wall) ds_list_add(array[i], id);<br />             break; <br />         case 1:<br />             with (obj_Door) ds_list_add(array[i], id);<br />             break; <br />         case 2:<br />             with (obj_Chest) ds_list_add(array[i], id);<br />             break; <br />         } <br />     }
  </p>
  <p>In the above code we've created a 3 item array and assigned a DS list to each of them, and then we've populated the different lists with the instance IDs of various objects in the game. Now, to access an ID in one of the lists we can do the following:</p>
  <p class="code">var _list = array[0];<br /> var _id = ds_list_find_value(_list, 0);</p>
  <p>However, you can do the same thing using chained accessors in a much cleaner way that uses less code:</p>
  <p class="code">var _id = array[0][| 0];</p>
  <p>You can chain multiple accessors together in this way and they can be of multiple types to get access to the information stored in each part of the nested structure. Here are some more examples:</p>
  <p class="code">// Access a grid that has been added to a list that is part of a map:<br /> var _a = data[? "lists"][| 0][# 0, 0];<br /> <br /> // Access an array nested in a list from a script and modify it:<br /> data[| 0][@ 10] = 100;<br /> <br /> // Access a map nested in a grid nested in a list nested in an array:<br /> data[0][| 10][# 3, 4][? "key"] = "hello world";</p>
  <p>Using chained accessors for things not only means you can write more compact code, it will also permit you to use iteration (for example, using a <a href="Language_Features/for.htm"><tt>for</tt></a> loop) and other techniques to access your data in a cleaner and more intuitive manner.</p>
  <p>It is worth noting that when using accessors in this way, you should always use the <span class="inline">@</span> accessor for arrays, as otherwise you will be adding extra overhead to any actions being performed. As mentioned above, by default arrays are passed by reference into functions and then use the "copy on write" behavior when modified. However, if the array is part of a chain, then the previous item in the chain will be updated with the copied array and the "original" will be deleted. For example, doing something like this:</p>
  <p class="code">// In an object event<br /> data[| 0][0] = 100;<br /> <br /> // In a function<br /> data[| 0][0] = 200;</p>
  <p>achieves the same results as doing this:</p>
  <p class="code">// In an object event<br /> data[| 0][0] = 100;<br /> <br /> // In a function<br /> data[| 0][@ 0] = 200;</p>
  <p>However, the second example is better as it works without the unnecessary overhead of copying the entire array first.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Back: <a href="GML_Overview.htm">GML Overview</a></div>
        <div style="float:right">Next: <a href="Script_Functions.htm">Script Functions And Variables</a></div>
      </div>
    </div>
    <h5>© Copyright YoYo Games Ltd. 2020 All Rights Reserved</h5>
  </div>
  <!-- KEYWORDS
div
mod
bitwise operators
bitshift
and
or
xor 
&amp;&amp;
||
^^
%
|
&amp;
^
&lt;&lt;
&gt;&gt;
bitwise or
bitwise and
bitwise xor
bitshift left
bitshift right
&lt;
&lt;=
==
!=
&gt;
&gt;=
++
$
hexadecimal
-->
  <!-- TAGS
expressions_operators
-->

</body></html>