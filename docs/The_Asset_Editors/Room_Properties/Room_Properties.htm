<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>

  <script type="text/javascript" language="JavaScript">
    //<![CDATA[
    function reDo() {
      if (innerWidth != origWidth || innerHeight != origHeight)
        location.reload();
    }
    if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
      origWidth = innerWidth;
      origHeight = innerHeight;
      onresize = reDo;
    }
    onerror = null;
  //]]>
  </script>
  <style type="text/css">/*<![CDATA[*/

    < !-- div.WebHelpPopupMenu {
      position: absolute;
      left: 0px;
      top: 0px;
      z-index: 4;
      visibility: hidden;
    }

    p.WebHelpNavBar {
      text-align: right;
    }

    -->
  
/*]]>*/</style>

  <script type="text/javascript">//<![CDATA[

    gRootRelPath = "../..";
    gCommonRootRelPath = "../..";
    gTopicId = "5.3.0_2";
  
//]]></script>

  <script type="text/javascript" src="../../template/scripts/rh.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/common.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/topic.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/topicwidgets.min.js"></script>
<script type="text/javascript" src="../../whxdata/projectsettings.js"></script>
  <link rel="stylesheet" type="text/css" href="../../template/styles/topic.min.css" />
  <link rel="stylesheet" type="text/css" href="../../template/Charcoal_Grey/topicheader.css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <title>ルームプロパティ</title>
  <meta name="topic-status" content="Draft" />

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>ルームプロパティ</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing the different room properties" />
  <meta name="rh-index-keywords" content="Rooms - Room Settings" />
  <meta name="search-keywords" content="room settings,cameras,viewports,room size,room properties,view cameras" />
</head>

<body>
  <div class="topic-header rh-topicheader-hide" id="rh-topic-header" onclick="rh._.goToFullLayout()">
    <div class="logo">
    </div>
    <div class="nav">
      <div class="title" title="ルームプロパティ">
        <span>ルームプロパティ</span>
      </div>
      <div class="gotohome" title="ページをすべて表示するにはここをクリック">
        <span>ページをすべて表示するにはここをクリック</span>
      </div>
    </div>
  </div>
  <div class="topic-header-shadow"></div>



  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>ルームプロパティ</h1>
  <p><img alt="ルームエディタのプロパティ" class="center" src="../../assets/Images/Asset_Editors/Editor_Room_RoomSettings.png" style="width: 100%; max-width: 335px;" />ルームプロパティの領域では、継承の切り替えやルームの名前、ルームを<strong>永続的</strong>にするかを設定できます。普通はルームを出てから戻ってきても、そのルームは初期設定にリセットされます。ほとんどのゲームでは問題ありませんが、RPG のような一方通行でなく、ルームを行ったり来たりするゲームの場合、最後に出ていった状態のままにしておきたいはずです。<strong>永続的</strong>はそのような場合のためのオプションで、チェックを入れるとルームの状態が記憶され、戻ってきても最後に出ていったままの状態となり、ゲームを再起動しないかぎり開始時の状態にリセットされなります。ただし永続的としてチェックしているオブジェクトは<em></em>例外であり、それらのインスタンスはルームに<em>留まらず</em>、次のルームまで移動します。</p>
  <p>その下にあるのは<strong>表示バッファをクリア</strong>というオプションです。このオプションがチェックされている場合、<a class="tooltip" title="表示バッファは、あらゆるものが最終的に描画される「キャンバス」です。表示バッファを直接対象とするイベント（Pre Drawイベントなど）もありますが、それ以外のイベントはまずアプリケーションサーフェスを対象とし、それから表示バッファに描画を行います。">表示バッファ</a>が単色で塗りつぶされます。ビューが常に画面全体を覆っていたり、背景が全画面描画されているならチェックを外しても問題ありませんが（再描画が省略されるためゲームの最適化につながります）、ビューを重ねていて画面上に空きスペースが残っている場合や、背景画像が少しでも透けている場合はチェックを入れるようにしてください。そうするとビューがない部分も指定した描画色で塗りつぶされます。なお現時点では描画色を設定するには、コードから <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/The_Game_Window/window_set_colour.htm"><span class="inline">window_set_colour()</span></a>関数を呼び出す必要があります。</p>
  <p class="note"><strong>注意</strong>: アスペクト比の自動補正を<a href="../../Settings/Game_Options.htm">ゲームオプション</a>から有効にしている場合、このオプションは<strong>常に</strong>チェックしておきましょう。そうしないとゲームが描画されるレターボックス（黒枠）の表示がおかしくなります。オプションを利用しない場合はチェックを外すと、ゲームのパフォーマンスが少しだけ向上します （Android などのモバイルプラットフォームでは特に有効です）。</p>
  <p>ルームには大きさがあり、ピクセル単位で幅と高さを設定しなくてはなりません。あとは必要に応じて<strong>生成コード</strong>を追加しましょう。生成コードは下のボタンから追加でき（その隣にある継承ボタンからは、ルームに生成コードを引き継がせるかを切り替えできます）、ボタンをクリックするとコードエディタ、または DnD™ エディタが開きます。エディタに入力した関数 / アクションおよびコードはルームの「<em>開始時</em>」に実行され、各インスタンスの Create イベントよりも後、Room Start イベントよりも前に実行されます（イベントの順番については<a href="../Object_Properties/Event_Order.htm">こちら</a>に詳しい情報があります）。生成コードはルームに入るたびに実行されます。永続的としてフラグ付けされている場合は最初に入ったときにだけ実行され、それ以降は実行されません。</p>
  <p>一番下にあるボタンをクリックすると、このように<strong>インスタンス生成順序</strong>ウィンドウが開きます。</p>
  <p><img alt="インスタンス生成順序ウィンドウ" class="center" src="../../assets/Images/Asset_Editors/Editor_Room_CreationOrder.png" style="width: 100%; max-width: 300px;" />このウィンドウにはルームの各インスタンスが、生成される順番どおりにリスト表示されます。特定のインスタンスを他のインスタンスより先に生成したい場合、そのインスタンスを目当ての位置にドラッグ<img alt="[左クリックアイコン]" class="icon" src="../../assets/Images/Icons/Icon_LMB.png" style="width: 100%; max-width: 21px;" />するといいでしょう。なおインスタンスはリストで指定したとおりに、上から下の順番で生成されます。</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <h1>カメラとビューポート</h1>
  <p>次のオプション群では、ルームの<strong>カメラ</strong>と<strong>ビューポート</strong>を設定できます。カメラビューを利用すると、ルームの各部分を画面上のさまざまな位置に描画したり、ルームのある部分だけを画面全体に描画するといった動作ができます。たとえば多くの横スクロールゲームでは、カメラビューをプレイヤーキャラクターに追従させています。ステージ全体を画面内に収めてしまうと、プレイヤーキャラクターがあまりにも小さく表示されてしまうだけでなく、先の展開が丸わかりになってしまうからです。カメラビューはマルチプレイや対戦型のゲームにも利用でき、画面を分割するよう設定すれば片方の画面にプレイヤーを、もう片方の画面に相手を映すことができます。GameMaker Studio 2 ではこのような仕組みを、カメラビューによって簡単に実現できます。</p>
  <p><img alt="カメラとビューポートのプロパティ" class="center" src="../../assets/Images/Asset_Editors/Editor_Room_RoomViews.png" style="width: 100%; max-width: 319px;" />ビュープロパティの上部からはビューの継承切り替えができるほか、<strong>ビューポートを有効</strong>のオプションもあります。このオプションは、カメラビューがゲーム内で有効となる前に<em>フラグ付けしなくてはなりません</em>。</p>
  <p class="note"><strong>メモ</strong>: 継承のオン / オフは 3 つあるビューポートの中心設定から切り替えられますが、それぞれのカメラビューごとに継承を切り替えることも可能です。</p>
  <p>隣にあるのは<strong>ビューポートの背景をクリア</strong>というチェックボックスで、<a class="tooltip" title="The application surface is a special built-in surface that GameMaker Studio 2 will draw everything to in the Draw Events of a game (a surface is essentially an area of memory reserved for graphics). This surface is then drawn to the display buffer at the end of each game frame, displaying its contents to the player.">アプリケーションサーフェス</a>をウィンドウ色でクリアします。サーフェス全体に描画されるとわかっているならチェックを外しても問題ありません。</p>
  <p>カメラビューを定義している値には 2 つの分類があり、カメラビュー、ビューが描画される画面上のポートごとに分かれています。混同しがちなので、値を定義する前に少し補足をしましょう。</p>
  <ul class="colour">
    <li><strong>カメラ</strong>: 画面上に表示されるルームの地点（ルームエディタでの抽象地点にあたり、ビューおよびビューポート設定から自動的に位置が設定されます）</li>
    <li><strong>ビュー</strong>: カメラの視界であり、カメラの位置、射影、回転に基づいています。</li>
    <li><strong>ビューポート</strong>: カメラビューが表示される物理的画面の範囲です。</li>
  </ul>
  <p><img alt="カメラビューの例" class="center" src="../../assets/Images/Asset_Editors/Camera_Example.png" style="width: 100%; max-width: 854px;" />So, for example, this means that you can have a 640x480 camera view into your room, and then set the port to 320x240, which will display the view scaled down to that sized port on the screen, and you can also do the same and set the view to a smaller value and the port to larger making the image scale up to fit the port size and be shown on the screen larger than it is. In this way you can maintain a screen (port) size while changing the camera view to display more or less of the room in the same area of the screen.</p>
  <p>The camera view is always defined as a rectangular area in the room, where you specify the position of the top-left corner, the width and the height of this area. Then you must specify where this area is shown in the window on the screen by defining the view port, where again you specify the position of the top-left corner and the size (note that anything other than 0,0 for the top left corner can give strange results). You can have more than one port and they can overlap, in which case they are drawn in the indicated order one on top of the other.</p>
  <p>Please realise that the overall screen area is <em>always defined as a rectangular area</em>, so your ports, even when offset, will form a rectangle, with any empty spaces being filled in by the window colour of the <a class="tooltip" title="表示バッファは、あらゆるものが最終的に描画される「キャンバス」です。表示バッファを直接対象とするイベント（Pre Drawイベントなど）もありますが、それ以外のイベントはまずアプリケーションサーフェスを対象とし、それから表示バッファに描画を行います。">display buffer</a>, meaning that in these circumstances you should always have <strong>Clear Display Buffer</strong> checked or else you will get odd artefacts drawn in the spaces between ports. The image below illustrates this, where there are two offset view ports visible, yet they make a square window, and "underneath" there are lines being drawn to the display buffer:</p>
  <p><img alt="Object Editor Post Draw" class="center" src="../../assets/Images/Asset_Editors/Editor_Object_PostDraw.png" style="width: 100%; max-width: 710px;" />Cameras also have the <strong>Object Following </strong>option. This is for when you want the camera to "follow" (ie: maintain the view focused on) a certain object. To do this you must click <img alt="LMB Icon" class="icon" src="../../assets/Images/Icons/Icon_LMB.png" style="width: 100%; max-width: 21px;" /> on the menu icon and select an object from the list that pops up (if there are multiple instances of this object in the room, only one of them is followed by the camera).</p>
  <p>The normal behaviour for a camera is to only move when the instance being followed gets too close to a "buffer" zone that makes an invisible boundary around the edge of the view. This zone can be defined by you using the <strong>Horizontal Border </strong>and <strong>Vertical Border </strong>values, so - for example - setting these values to 64 will mean that the view will not start to move and follow the character until it reaches 64 pixels from the edge of the view.</p>
  <p>Finally you can indicate the <strong>horizontal</strong> and <strong>vertical speed </strong>at which the camera moves when the character has reached the buffer zone, and this has a default value of -1. This default value is basically "instantaneous" and means that the moment the follow instance is outside the horizontal border or vertical border buffer zone, the view will skip to its current position. Now, this is not always what you want and so you can set the vertical and horizontal scrolling speed for the camera by setting the values to something other than -1. Note that a value of 0 will cause the view to not move at all, and any other positive value is how many pixels it will move in any frame, so setting the horizontal speed to 5 will have the view follow the object at 5 pixels per frame horizontally.</p>
  <p> </p>
  <p> </p>
  <h1>Room Physics</h1>
  <p>Before you can use the built in physics functions in your games, you must tell GameMaker Studio 2 that the room is a physics room. To do this, you must tick the option to <strong>Enable Physics </strong>at the top of the <em>Room Physics</em> section (you can also toggle the inheritance of this section independently of the rest of the room settings). Once you have done that you can then continue on to set up the physics world properties, which are some basic properties that you must have pre-defined before your room will allow physics instances to work as such. For a more precise control over the world you can use code (see the <a href="../../GameMaker_Language/GML_Reference/Physics/Physics.htm">Physics Functions</a> for more information).</p>
  <p><img alt="Room Physics Properties" class="center" src="../../assets/Images/Asset_Editors/Editor_Room_RoomPhysics.png" style="width: 100%; max-width: 355px;" />The next thing you must do is set up the <strong>Gravity </strong>of the world. The strength and direction of this is calculated as a <a class="tooltip" title="A vector is a mathematical construct that has a size, called the magnitude, and a direction. In GameMaker, a vector is usually used to show the distance and direction something moved in. A vector can also be used to define images and certain image formats like SWF use vector maths to define the images they contain.">vector</a> of the x/y position that you set around a (0, 0) point. So, an x of 0 and a y of 1 will set the gravity direction as being <em>down </em>with a force of 1 meter per second (for a more detailed explanation see - <a href="../../GameMaker_Language/GML_Reference/Physics/The_Physics_World/The_Physics_World.htm">The Physics World</a>).</p>
  <p>Finally you must set the ratio of<strong> Pixels To Meters</strong> for GameMaker Studio 2 to use as a base for all its physics calculations. This is because the physics functions work on real-world measurements, which is why we must set this value, and you'll want to adjust this setting until the average pixel size of the objects you are using translates roughly into simulated physics objects of an appropriate size.</p>
  <p>It should be noted that enabling physics in a room means that all instances in the room <em>must use the physics functios and variables to move</em>. Basically, you have "traditional" movement, where you can set the X/Y position of an instance or set its speed and direction, and then you have the "physics" movement, which requires physical forces and impulses to move around. These systems are <strong>mutually exlusive</strong>, and you cannot move a physics instance using non-physics functions and you cannot move a non-physics instance using the physics funtions.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Back: <a href="../Rooms.htm">The Room Editor</a></div>
        <div style="float:right">Next: <a href="Room_Inheritance.htm">Room Inheritance</a></div>
      </div>
    </div>
    <h5>© Copyright YoYo Games Ltd. 2020 All Rights Reserved</h5>
  </div>
  <!-- KEYWORDS
Room Properties
View Ports
View Cameras
-->
  <!-- TAGS
rooms_properties
-->

</body></html>